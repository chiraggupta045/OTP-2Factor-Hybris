/**
 *
 */
package com.otp.facade.impl;

import com.otp.service.OtpIntegrationService;
import de.hybris.platform.core.model.user.UserModel;
import de.hybris.platform.servicelayer.config.ConfigurationService;
import de.hybris.platform.servicelayer.model.ModelService;
import de.hybris.platform.servicelayer.user.UserService;

import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.otp.facade.SecretKeyFacade;
import com.warrenstrange.googleauth.GoogleAuthenticator;
import com.warrenstrange.googleauth.GoogleAuthenticatorKey;



@Component
public class DefaultSecretKeyFacade implements SecretKeyFacade
{
	/** User Service */
	@Autowired
	private UserService userService;

	/** Model Service */
	@Autowired
	private ModelService modelService;

	/** Configuration Service */
	@Autowired
	private ConfigurationService configurationService;

	/** OTP Integration Service */
	@Autowired
	private OtpIntegrationService otpIntegrationService;

	/** Logger Instance for DefaultSecretKeyFacade */
	private static final Logger LOG = Logger.getLogger(DefaultSecretKeyFacade.class);


	/**
	 * this method is to check loggedIn user is authenticate or not
	 * @return
	 * @throws Exception
	 */
	@Override
	public boolean checkUserAuthentication()
	{
		if (userService.getCurrentUser().isIsEnabledTwoFactorAuthentication())
		{
			// Do Nothing and return TRUE
			LOG.debug("Two factor Authentication is already enabled for this user");
			return Boolean.TRUE;
		}
		else if (!userService.getCurrentUser().isIsEnabledTwoFactorAuthentication()
				&& StringUtils.isEmpty(userService.getCurrentUser().getSecretKeyForOTP()))
		{
			final UserModel userModel = userService.getCurrentUser();
			final String secretKey = generateSecretKey();
			if(StringUtils.isNotEmpty(secretKey))
			{
				userModel.setIsEnabledTwoFactorAuthentication(Boolean.TRUE);
				userModel.setSecretKeyForOTP(secretKey);
				otpIntegrationService.getGoogleAuthenticatorBarCode(secretKey,userService);
				modelService.save(userModel);
				LOG.debug("New User Enabled for 2-Factor Authentication:" + userModel.getUid());
				return Boolean.FALSE;
			}
			else {
				LOG.error("Secret Key was not generated for the Logged in User"+ userModel.getUid());
			}
		}
		return Boolean.TRUE;
	}

	/**
	 * Generate A random Secret Key from the GoogleAuthenticator API
	 * @return
	 */
	public String generateSecretKey()
	{
		final GoogleAuthenticator gAuth = new GoogleAuthenticator();
		try {
			final GoogleAuthenticatorKey googleAuthKey = gAuth.createCredentials();
			return googleAuthKey.getKey();
		}
		catch (Exception e)
		{
			LOG.error("Error occurred while creating secret key using GoogleAuthenticator API" +e.getMessage());
		}
		return StringUtils.EMPTY;
	}

	/**this method is validate otp entered by user is valid or not
	 * @param otp
	 * @return
	 */
	@Override
	public boolean validateGoogleAuthBasedOtp(final String otp)
	{
		final UserModel userModel = userService.getCurrentUser();
		if (StringUtils.isNotEmpty(userModel.getSecretKeyForOTP()))
		{
			final GoogleAuthenticator gAuth = new GoogleAuthenticator();
			try {
				//this method of google authenticator will verify the otp
				return gAuth.authorize(userModel.getSecretKeyForOTP(), Integer.parseInt(otp));
			}
			catch (Exception e)
			{
				LOG.error("Error occurred in comparison of OTP Entered and the OTP Generated by the GA App." +e.getMessage());
			}
		}
		return false;
	}

	/**
	 *this method will return the username of customer
	 * @return username
	 */
	@Override
	public String getCustomerUserName()
	{
		final UserModel userModel = userService.getCurrentUser();
		return userModel.getName();
	}
}